<!DOCTYPE html>
<html lang="en">
<body>
    <canvas id="canvas" width="150" height="150" style="float:left"></canvas>
    <script type="text/javascript">
        var canvas = document.getElementById('canvas');
        var ctx = canvas.getContext('2d');
        var myImageData = ctx.createImageData(canvas.width, canvas.height);
        var gradientArray,valueArray;
        initPerlin([100, 20, 20]);
        setInterval("interval()",10);
        var add = 0.01, p = 0;
        function interval() {
            var myImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            for (var i = 0; i < canvas.height; i++)
                for (var j = 0; j < canvas.width; j++) {
                    var color = perlinNoise([p, i / 100, j / 100]);
                    color = (color - Math.floor(color)) * 255;
                    for (var k = 0; k < 3; k++) myImageData.data[i * canvas.width * 4 + j * 4 + k] = color;
                    myImageData.data[i * canvas.width * 4 + j * 4 + 3] = 255;
                }
            ctx.putImageData(myImageData, 0, 0);
            p = p + add;
            if (p >= 100) p = 0;
        }
        function pointCopy(point)
        {
            var newPoint = new Array();
            for (var i = 0; i < point.length; i++) newPoint[i] = point[i];
            return newPoint;
        }
        function getValue(point, array) {
            return (function _getValue(dimension, point, array) {
                if (dimension == point.length) return array;
                return _getValue(dimension + 1, point, array[point[dimension]]);
            }(0, point, array));
        }
        function initArray(size) {
            return (function _initArray(dimension, size) {
                if (dimension == size.length) return Math.random();
                var array = new Array();
                for (var i = 0; i < size[dimension]; i++) array[i] = _initArray(dimension + 1, size);
                return array;
            }(0, size));
        }
        function initGradient(size)
        {
            var gradient_size = size.concat([size.length]);
            var array = initArray(gradient_size);
            (function format(dimension, array, size) {
                if (dimension == size.length) {
                    for (var i = 0; i < size.length; i++) array[i] = array[i] * 2 - 1;
                    normalize(array);
                }
                else for (var i = 0; i < size[dimension]; i++) format(dimension + 1, array[i], size);
            }(0, array, size));
            return array;
        }
        function initPerlin(size) {
            gradientArray = initGradient(size);
            valueArray = initArray(size);
        }
        function s_curve(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
        function lerp(t, a, b) { return a + t * (b - a); }
        function normalize(vector) {
            var s = 0;
            for (var i = 0; i < vector.length; i++) s += vector[i] * vector[i];
            s = Math.sqrt(s);
            for (var i = 0; i < vector.length; i++) vector[i] = vector[i] / s;
        }
        function perlinNoise(point) {
            var floor = new Array();
            var ceil = new Array();
            var s_curve_value = new Array();
            for (var i = 0; i < point.length; i++) {
                floor[i] = Math.floor(point[i]);
                ceil[i] = Math.ceil(point[i]);
                s_curve_value[i] = s_curve(point[i] - floor[i]);
            }
            return (function dimensionLerp(dimension, point) {
                var pointFloor = pointCopy(point);
                pointFloor[dimension - 1] = floor[dimension - 1];
                var pointCeil = pointCopy(point);
                pointCeil[dimension - 1] = ceil[dimension - 1];
                if (dimension == 1) {
                    var gradientFloor = getValue(pointFloor, gradientArray);
                    var gradientCeil = getValue(pointCeil, gradientArray);
                    var u = getValue(pointFloor, valueArray), v = getValue(pointCeil, valueArray);
                    for (var i = 0; i < point.length; i++) u = u + pointFloor[i] * gradientFloor[i];
                    for (var i = 0; i < point.length; i++) v = v + pointCeil[i] * gradientCeil[i];
                    return lerp(s_curve_value[0], u, v);
                }
                return lerp(s_curve_value[dimension - 1], dimensionLerp(dimension - 1, pointFloor), dimensionLerp(dimension - 1, pointCeil));
            }(point.length, point));
        }
    </script>
</body>
</html>